/*
 * MusicDBDelimTextFileImportFrame.java
 *
 * Created on 10 March 2006, 17:10
 */

package org.imirsel.m2k.io.musicDB;

import java.util.HashMap;
import java.io.*;
import javax.swing.JOptionPane;
import java.util.ArrayList;
import javax.swing.table.DefaultTableModel;
import org.imirsel.m2k.util.retrieval.MusicDB;
import org.imirsel.m2k.util.noMetadataException;
import org.jdesktop.layout.GroupLayout;
import org.imirsel.m2k.util.Signal;
import org.imirsel.m2k.io.file.DeliminatedTextFileUtilities;

/**
 * Creates and displays a swing frame that imports an arbitrary CSV file of audio 
 * file metadata into a MusicDB object and facilitates mappings of CSV headers to 
 * common audio file metadata types (such as genre, artist or album).
 * @author kris
 */
public class MusicDBDelimTextFileImportFrame extends javax.swing.JFrame {
    HashMap<String,String> delimiterMenus;
    File retainedSelectedFile;
    String retainedDelimiter;
    int retainedHeaderRow = -1;
    java.util.Vector<String> metadataSelectionsVector;
    private MusicDB database = null;
    ArrayList labels = null;
    ArrayList metadataSelections = null;
    private boolean doneImport = false;
        
    /**
     * Creates new form MusicDBDelimTextFileImportFrame
     */
    public MusicDBDelimTextFileImportFrame() {
        initComponents();
        delimiterMenus = new HashMap<String,String>(3);
        delimiterMenus.put("Comma (,)" , ",");
        delimiterMenus.put("Tab (\\t)"  , "\t");
        delimiterMenus.put("Space ( )" , " ");
        
        retainedSelectedFile = null;
        retainedDelimiter = ",";
        
        metadataSelectionsVector = new java.util.Vector<String>();
        
        metadataSelectionsVector.add("None");
        metadataSelectionsVector.add(Signal.PROP_FILE_LOCATION);
        metadataSelectionsVector.add(Signal.PROP_ALBUM);
        metadataSelectionsVector.add(Signal.PROP_ARTIST);
        metadataSelectionsVector.add(Signal.PROP_GENRE);
        metadataSelectionsVector.add(Signal.PROP_MOOD);
        metadataSelectionsVector.add(Signal.PROP_TRACKNAME);
        metadataSelectionsVector.add(Signal.PROP_ALT_GENRE);
        metadataSelectionsVector.add(Signal.PROP_ALT_YEAR);
        metadataSelectionsVector.add(Signal.PROP_CLASS);
        
        setDatabase(new MusicDB());
        
    }
    
    
    /**
     * Creates new form MusicDBDelimTextFileImportFrame taking the MusicDB Object to 
     * populate and an <CODE>MusicDBDelimTextFileImportModule</CODE> as input.
     * @param theDB The MusicDB Object to populate.
     */
    public MusicDBDelimTextFileImportFrame(MusicDB theDB) {
        initComponents();
        delimiterMenus = new HashMap(3);
        delimiterMenus.put("Comma (,)" , ",");
        delimiterMenus.put("Tab (\\t)"  , "\t");
        delimiterMenus.put("Space ( )" , " ");
        
        retainedSelectedFile = null;
        retainedDelimiter = ",";
        
        metadataSelectionsVector = new java.util.Vector();
        
        metadataSelectionsVector.add("None");
        metadataSelectionsVector.add(Signal.PROP_FILE_LOCATION);
        metadataSelectionsVector.add(Signal.PROP_ALBUM);
        metadataSelectionsVector.add(Signal.PROP_ARTIST);
        metadataSelectionsVector.add(Signal.PROP_GENRE);
        metadataSelectionsVector.add(Signal.PROP_MOOD);
        metadataSelectionsVector.add(Signal.PROP_TRACKNAME);
        metadataSelectionsVector.add(Signal.PROP_ALT_GENRE);
        metadataSelectionsVector.add(Signal.PROP_CLASS);
        setDatabase(theDB);
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        ImportTab = new javax.swing.JTabbedPane();
        CSVImportPanel = new javax.swing.JPanel();
        CSVFileScrollPanel = new javax.swing.JScrollPane();
        CSVFileTable = new javax.swing.JTable();
        CSVFileChooser = new javax.swing.JFileChooser();
        delimiterMenu = new javax.swing.JComboBox();
        delimiterLabel = new javax.swing.JLabel();
        SelectFileTitle = new javax.swing.JLabel();
        PreviewButton = new javax.swing.JButton();
        SelectHeaderRowPanel = new javax.swing.JPanel();
        SelectHeaderRowTitle = new javax.swing.JLabel();
        SelectHeaderRowScrollPane = new javax.swing.JScrollPane();
        SelectHeaderRowTable = new javax.swing.JTable();
        ConfirmHeaderSelection = new javax.swing.JButton();
        MapValuesToMetadataPanel = new javax.swing.JPanel();
        MapValuesTitle = new javax.swing.JLabel();
        HeaderMappingScrollPane = new javax.swing.JScrollPane();
        HeaderMappingPanel = new javax.swing.JPanel();
        ImportDataButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Import Music database CSV File");
        setName("CSVImportFrame"); // NOI18N

        CSVFileTable.setBorder(javax.swing.BorderFactory.createEmptyBorder(1, 1, 1, 1));
        CSVFileTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {"<preview a file>"}
            },
            new String [] {
                "No data to preview"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        CSVFileTable.setEnabled(false);
        CSVFileTable.setRowSelectionAllowed(false);
        CSVFileScrollPanel.setViewportView(CSVFileTable);

        CSVFileChooser.setApproveButtonText("Load CSV File");
        CSVFileChooser.setApproveButtonToolTipText("Load the select CSV file");
        CSVFileChooser.setBackground(java.awt.Color.white);
        CSVFileChooser.setDialogType(javax.swing.JFileChooser.CUSTOM_DIALOG);
        CSVFileChooser.setToolTipText("Select the file to import");
        CSVFileChooser.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                CSVFileChooserActionPerformed(evt);
            }
        });

        delimiterMenu.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Comma (,)", "Tab (\\t)", "Space ( )" }));

        delimiterLabel.setText("Delimiter");

        SelectFileTitle.setFont(new java.awt.Font("Arial", 1, 18));
        SelectFileTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        SelectFileTitle.setText("Select and load the CSV file");
        SelectFileTitle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        PreviewButton.setText("Preview");
        PreviewButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PreviewButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout CSVImportPanelLayout = new org.jdesktop.layout.GroupLayout(CSVImportPanel);
        CSVImportPanel.setLayout(CSVImportPanelLayout);
        CSVImportPanelLayout.setHorizontalGroup(
            CSVImportPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, CSVImportPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(PreviewButton)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 319, Short.MAX_VALUE)
                .add(delimiterLabel)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(delimiterMenu, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
            .add(CSVFileChooser, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 595, Short.MAX_VALUE)
            .add(CSVImportPanelLayout.createSequentialGroup()
                .add(180, 180, 180)
                .add(SelectFileTitle)
                .addContainerGap(178, Short.MAX_VALUE))
            .add(CSVImportPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(CSVFileScrollPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 555, Short.MAX_VALUE)
                .addContainerGap())
        );
        CSVImportPanelLayout.setVerticalGroup(
            CSVImportPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(CSVImportPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(SelectFileTitle)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(CSVFileChooser, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(8, 8, 8)
                .add(CSVImportPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(delimiterLabel)
                    .add(delimiterMenu, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(PreviewButton))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(CSVFileScrollPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 119, Short.MAX_VALUE)
                .addContainerGap())
        );

        ImportTab.addTab("Load CSV file (1)", CSVImportPanel);

        SelectHeaderRowPanel.setEnabled(false);

        SelectHeaderRowTitle.setFont(new java.awt.Font("Arial", 1, 18));
        SelectHeaderRowTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        SelectHeaderRowTitle.setText("Select header row");
        SelectHeaderRowTitle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        SelectHeaderRowTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null}
            },
            new String [] {
                "<No data loaded>"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class
            };
            boolean[] canEdit = new boolean [] {
                false
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        SelectHeaderRowScrollPane.setViewportView(SelectHeaderRowTable);

        ConfirmHeaderSelection.setText("Confirm selection");
        ConfirmHeaderSelection.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ConfirmHeaderSelectionActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout SelectHeaderRowPanelLayout = new org.jdesktop.layout.GroupLayout(SelectHeaderRowPanel);
        SelectHeaderRowPanel.setLayout(SelectHeaderRowPanelLayout);
        SelectHeaderRowPanelLayout.setHorizontalGroup(
            SelectHeaderRowPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, SelectHeaderRowPanelLayout.createSequentialGroup()
                .add(SelectHeaderRowPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, SelectHeaderRowPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .add(SelectHeaderRowScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 555, Short.MAX_VALUE))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, SelectHeaderRowPanelLayout.createSequentialGroup()
                        .add(213, 213, 213)
                        .add(SelectHeaderRowTitle))
                    .add(SelectHeaderRowPanelLayout.createSequentialGroup()
                        .addContainerGap(435, Short.MAX_VALUE)
                        .add(ConfirmHeaderSelection)))
                .addContainerGap())
        );
        SelectHeaderRowPanelLayout.setVerticalGroup(
            SelectHeaderRowPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(SelectHeaderRowPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(SelectHeaderRowTitle)
                .add(16, 16, 16)
                .add(SelectHeaderRowScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 524, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(ConfirmHeaderSelection)
                .addContainerGap())
        );

        ImportTab.addTab("Select header row (2)", SelectHeaderRowPanel);

        MapValuesToMetadataPanel.setEnabled(false);

        MapValuesTitle.setFont(new java.awt.Font("Arial", 1, 18));
        MapValuesTitle.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        MapValuesTitle.setText("Select which headers to import as Metadata");
        MapValuesTitle.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);

        org.jdesktop.layout.GroupLayout HeaderMappingPanelLayout = new org.jdesktop.layout.GroupLayout(HeaderMappingPanel);
        HeaderMappingPanel.setLayout(HeaderMappingPanelLayout);
        HeaderMappingPanelLayout.setHorizontalGroup(
            HeaderMappingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 584, Short.MAX_VALUE)
        );
        HeaderMappingPanelLayout.setVerticalGroup(
            HeaderMappingPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 557, Short.MAX_VALUE)
        );

        HeaderMappingScrollPane.setViewportView(HeaderMappingPanel);

        ImportDataButton.setText("Import data");
        ImportDataButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ImportDataButtonActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout MapValuesToMetadataPanelLayout = new org.jdesktop.layout.GroupLayout(MapValuesToMetadataPanel);
        MapValuesToMetadataPanel.setLayout(MapValuesToMetadataPanelLayout);
        MapValuesToMetadataPanelLayout.setHorizontalGroup(
            MapValuesToMetadataPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(MapValuesToMetadataPanelLayout.createSequentialGroup()
                .add(MapValuesToMetadataPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(MapValuesToMetadataPanelLayout.createSequentialGroup()
                        .add(249, 249, 249)
                        .add(ImportDataButton))
                    .add(MapValuesToMetadataPanelLayout.createSequentialGroup()
                        .add(115, 115, 115)
                        .add(MapValuesTitle))
                    .add(MapValuesToMetadataPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .add(HeaderMappingScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 555, Short.MAX_VALUE)))
                .addContainerGap())
        );
        MapValuesToMetadataPanelLayout.setVerticalGroup(
            MapValuesToMetadataPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(MapValuesToMetadataPanelLayout.createSequentialGroup()
                .addContainerGap()
                .add(MapValuesTitle)
                .add(17, 17, 17)
                .add(HeaderMappingScrollPane, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 523, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(ImportDataButton)
                .addContainerGap())
        );

        ImportTab.addTab("Map values to metadata (3)", MapValuesToMetadataPanel);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(ImportTab, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 616, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(ImportTab, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 681, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void ImportDataButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ImportDataButtonActionPerformed
        //collect and check mappings
        ArrayList mappings = new ArrayList();
        ArrayList metadataTypes = new ArrayList();
        //int artistMapping = -1;
        //int albumMapping = -1;
        //int genreMapping = -1;
        int fileMapping = -1;
        
        for (int i = 0; i < this.metadataSelections.size(); i++) {
            for (int j = 0; j < this.metadataSelectionsVector.size(); j++) {
                if(((javax.swing.JComboBox)this.metadataSelections.get(i)).getSelectedItem().equals(Signal.PROP_FILE_LOCATION))
                {
                    if (fileMapping != -1){
                        JOptionPane.showMessageDialog(null, "Duplicate file location mapping detected, you can only map one header to any one metadata type!", "Duplicate file location mapping detected!", JOptionPane.ERROR_MESSAGE);
                        return;
                    }else{
                        fileMapping = i;
                        break;
                    }
                }else if(((javax.swing.JComboBox)this.metadataSelections.get(i)).getSelectedItem().equals("None")){
                //do nothing
                }else if(((javax.swing.JComboBox)this.metadataSelections.get(i)).getSelectedItem().equals(this.metadataSelectionsVector.get(j)))
                {
                    if (metadataTypes.contains((String)this.metadataSelectionsVector.get(j))){
                        JOptionPane.showMessageDialog(null, "Duplicate " + (String)this.metadataSelectionsVector.get(j) + " mapping detected, you can only map one header to any one metadata type!", "Duplicate album mapping detected!", JOptionPane.ERROR_MESSAGE);
                        return;
                    }else{
                        mappings.add(new Integer(i));
                        metadataTypes.add((String)this.metadataSelectionsVector.get(j));
                        this.database.indexKey((String)this.metadataSelectionsVector.get(j));
                        break;
                    }
                }
            }
            
/*            if (((javax.swing.JComboBox)this.metadataSelections.get(i)).getSelectedItem().equals(Signal.PROP_ALBUM))
            {
                if (albumMapping != -1){
                    JOptionPane.showMessageDialog(null, "Duplicate album mapping detected, you can only map one header to any one metadata type!", "Duplicate album mapping detected!", JOptionPane.ERROR_MESSAGE);
                    return;
                }else{
                    albumMapping = i;
                    this.database.indexKey(Signal.PROP_ALBUM);
                }
            }else if(((javax.swing.JComboBox)this.metadataSelections.get(i)).getSelectedItem().equals(Signal.PROP_ARTIST))
            {
                if (artistMapping != -1){
                    JOptionPane.showMessageDialog(null, "Duplicate artist mapping detected, you can only map one header to any one metadata type!", "Duplicate artist mapping detected!", JOptionPane.ERROR_MESSAGE);
                    return;
                }else{
                    artistMapping = i;
                    this.database.indexKey(Signal.PROP_ARTIST);
                }
            }else if(((javax.swing.JComboBox)this.metadataSelections.get(i)).getSelectedItem().equals(Signal.PROP_GENRE))
            {
                if (genreMapping != -1){
                    JOptionPane.showMessageDialog(null, "Duplicate genre mapping detected, you can only map one header to any one metadata type!", "Duplicate genre mapping detected!", JOptionPane.ERROR_MESSAGE);
                    return;
                }else{
                    genreMapping = i;
                    this.database.indexKey(Signal.PROP_GENRE);
                }
            }else 
 */
        }
        
        if (fileMapping == -1) 
        {
            JOptionPane.showMessageDialog(null, "A mapping must be specified that identifies the unique file location metadata of each file.", "No file location mapping!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        //fill in database
        String[][] csvData;
        try {
            csvData = DeliminatedTextFileUtilities.getDelimTextDataBlock(this.retainedSelectedFile, this.retainedDelimiter, this.retainedHeaderRow);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(null, "IOException occured while importing data", "IOException occured during import!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        for (int i = 0; i < csvData.length; i++) {
            Signal aSignal = new Signal(csvData[i][fileMapping]);
            
            /*if(artistMapping != -1){
                aSignal.setMetadata(Signal.PROP_ARTIST,csvData[i][artistMapping]);
            }
            if(genreMapping != -1){
                aSignal.setMetadata(Signal.PROP_GENRE,csvData[i][genreMapping]);
            }
            if(albumMapping != -1){
                aSignal.setMetadata(Signal.PROP_ALBUM,csvData[i][albumMapping]);
            }*/
            for (int j = 0; j < mappings.size(); j++) {
                aSignal.setMetadata((String)metadataTypes.get(j), csvData[i][((Integer)mappings.get(j)).intValue()]);
            }
            
            try {
                this.database.addFileToDatabase(aSignal);
            } catch (noMetadataException ex) {
                throw new RuntimeException("Required metadata for indexing not found!", ex);
            }
        }
        
        //output database
        this.doneImport = true;
        JOptionPane.showMessageDialog(null, "Data on " + this.database.size() + " audio files was imported from: " + this.retainedSelectedFile.getPath() + " and " + database.getIndexedMetadatas().size() + " metadata types were indexed" , "CSV File data imported!", JOptionPane.INFORMATION_MESSAGE);
        this.dispose();
    }//GEN-LAST:event_ImportDataButtonActionPerformed

    private void ConfirmHeaderSelectionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ConfirmHeaderSelectionActionPerformed
        int selectedRow = this.SelectHeaderRowTable.getSelectedRow();
        if (selectedRow < 0)
        {
            JOptionPane.showMessageDialog(null, "You must select a row of the CSV file to use as the header row!", "No header row selected!", JOptionPane.ERROR_MESSAGE);
            return;
        }
        
        retainedHeaderRow = selectedRow;
        
        String[] headers = null;
        try {
            headers = DeliminatedTextFileUtilities.loadDelimTextHeaders(retainedSelectedFile,retainedDelimiter,selectedRow);
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(null, "Unable to confirm header selection, an IOException occured!\n" + ex, "Unable to confirm header selection", JOptionPane.ERROR_MESSAGE);
            ex.printStackTrace();
            return;
        }
        
        //create editor controls
        labels = new ArrayList();
        metadataSelections = new ArrayList();
        
        for (int i = 0; i < headers.length; i++) {
            labels.add(new javax.swing.JLabel(headers[i],javax.swing.SwingConstants.LEFT));
            metadataSelections.add(new javax.swing.JComboBox(this.metadataSelectionsVector));
        }
        
        //Build mapping table
        javax.swing.JPanel aMappingPanel = HeaderMappingPanel;
        aMappingPanel.removeAll();
        GroupLayout layout = new GroupLayout(aMappingPanel);
        
        //layout mapping table
        aMappingPanel.setLayout(layout);
        layout.setAutocreateGaps(true);
        layout.setAutocreateContainerGaps(true);
        //horizontal groups
        GroupLayout.SequentialGroup hGroup = layout.createSequentialGroup();
        GroupLayout.ParallelGroup labelgroup = layout.createParallelGroup();
        GroupLayout.ParallelGroup combogroup = layout.createParallelGroup();
        for (int i = 0; i < headers.length; i++) {
            labelgroup.add((javax.swing.JLabel)labels.get(i));
            combogroup.add((javax.swing.JComboBox)metadataSelections.get(i));
        }
        hGroup.add(labelgroup).add(combogroup);
        layout.setHorizontalGroup(hGroup);
        //vertical groups
        GroupLayout.SequentialGroup vGroup = layout.createSequentialGroup();
        //ArrayList verticalGroups = new ArrayList();
        
        for (int i = 0; i < headers.length; i++) {
            GroupLayout.ParallelGroup aVerticalGroup = layout.createParallelGroup(GroupLayout.BASELINE);
            aVerticalGroup.add((javax.swing.JLabel)labels.get(i)).add((javax.swing.JComboBox)metadataSelections.get(i));
            vGroup.add(aVerticalGroup);
            //verticalGroups.add(aVerticalGroup);
        }
        
        layout.setVerticalGroup(vGroup);
        //this.HeaderMappingPanel = aMappingPanel;
        this.MapValuesToMetadataPanel.setEnabled(true);
        this.HeaderMappingScrollPane.validate();
        
        //Goto map values pane
        ImportTab.setSelectedIndex(2);
    }//GEN-LAST:event_ConfirmHeaderSelectionActionPerformed
    
    private void PreviewButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PreviewButtonActionPerformed
        File selectedFile = CSVFileChooser.getSelectedFile();
        if (selectedFile != null)
        {
            //Load table data and construct preview (max 50 lines)
            String delimiter = (String)this.delimiterMenus.get(this.delimiterMenu.getSelectedItem());
            DefaultTableModel csvTable;
            try {
                csvTable = this.getDelimTextTable(selectedFile, delimiter, -1, 50);
            } catch (IOException ex) {
                JOptionPane.showMessageDialog(null, "Unable to preview, an IOException occured!\n" + ex, "Unable to preview!", JOptionPane.ERROR_MESSAGE);
                ex.printStackTrace();
                return;
            }
            CSVFileTable.setModel(csvTable);
        }else
        {
            JOptionPane.showMessageDialog(null, "Unable to preview, no file selected!", "Unable to preview!", JOptionPane.ERROR_MESSAGE);
            return;
        }   
    }//GEN-LAST:event_PreviewButtonActionPerformed
    
    private void CSVFileChooserActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_CSVFileChooserActionPerformed
        if(evt.getActionCommand() == javax.swing.JFileChooser.APPROVE_SELECTION){
            retainedSelectedFile = CSVFileChooser.getSelectedFile();

            if (retainedSelectedFile != null)
            {
                //Load table data and construct selection table for next pane
                retainedDelimiter = (String)this.delimiterMenus.get(this.delimiterMenu.getSelectedItem());
                DefaultTableModel csvTable;
                try {
                    csvTable = this.getDelimTextTable(retainedSelectedFile, retainedDelimiter, -1, 100);
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(null, "Unable to load CSV File, an IOException occured!\n" + ex, "Unable to load CSV File!", JOptionPane.ERROR_MESSAGE);
                    ex.printStackTrace();
                    return;
                }
            
                //set table model on select header row panel
                this.SelectHeaderRowTable.setModel(csvTable);
                
                //Goto select header pane
                ImportTab.setSelectedIndex(1);
                SelectHeaderRowPanel.setEnabled(true);
                this.MapValuesToMetadataPanel.setEnabled(false);
            }else
            {
                JOptionPane.showMessageDialog(null, "Unable to load CSVfile, no file selected!", "Unable to load CSV file!", JOptionPane.ERROR_MESSAGE);
                return;
            }
        }else{//Close the panel
            System.out.println("Cancel button, RECEIVED: " + evt.getActionCommand() + ", approve: " + javax.swing.JFileChooser.APPROVE_SELECTION + ", cancel: " + javax.swing.JFileChooser.CANCEL_SELECTION);
            this.dispose();
        }
    }//GEN-LAST:event_CSVFileChooserActionPerformed
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JFileChooser CSVFileChooser;
    private javax.swing.JScrollPane CSVFileScrollPanel;
    private javax.swing.JTable CSVFileTable;
    private javax.swing.JPanel CSVImportPanel;
    private javax.swing.JButton ConfirmHeaderSelection;
    private javax.swing.JPanel HeaderMappingPanel;
    private javax.swing.JScrollPane HeaderMappingScrollPane;
    private javax.swing.JButton ImportDataButton;
    private javax.swing.JTabbedPane ImportTab;
    private javax.swing.JLabel MapValuesTitle;
    private javax.swing.JPanel MapValuesToMetadataPanel;
    private javax.swing.JButton PreviewButton;
    private javax.swing.JLabel SelectFileTitle;
    private javax.swing.JPanel SelectHeaderRowPanel;
    private javax.swing.JScrollPane SelectHeaderRowScrollPane;
    private javax.swing.JTable SelectHeaderRowTable;
    private javax.swing.JLabel SelectHeaderRowTitle;
    private javax.swing.JLabel delimiterLabel;
    private javax.swing.JComboBox delimiterMenu;
    // End of variables declaration//GEN-END:variables
    
    /**
     * Returns a table model representing the first N lines of a deliminated text file.
     * The headers may be extracted if the header row is specified.
     * @param csvFile The deliminated text file name and path.
     * @param delimiter The delimiter to use to read the file.
     * @param headerRow The number of the header row or -1 for no header row.
     * @param lines Number of lines to read or -1 for all of them.
     * @return a table model representing the first N lines of the deliminated text file.
     * @throws java.io.IOException Thrown if there is a problem reading the deliminated text file.
     * @throws java.io.FileNotFoundException Thrown if the deliminated text file is not found.
     */
    public DefaultTableModel getDelimTextTable(File csvFile, String delimiter, int headerRow, int lines) throws IOException, FileNotFoundException{
        String[][] csvData = DeliminatedTextFileUtilities.loadDelimTextData(csvFile, delimiter, lines);
        String[] headers;
        Class[] types = new Class[csvData[0].length];
        for (int i = 0; i < types.length; i++) {
            types[i] = java.lang.String.class;
        }
        if(headerRow <= -1)
        {
            //set headers
            headers = new String[csvData[0].length]; 
        }else{
            headers  = csvData[headerRow];
            //Truncate remaining data
            String[][] truncCSVData = new String[csvData.length - (headerRow + 1)][];
            for (int i = 0; i < (csvData.length - (headerRow + 1)); i++) {
                truncCSVData[i] = csvData[i + (headerRow + 1)];
            }
            csvData = truncCSVData;
        }
        DefaultTableModel tableModel = new DefaultTableModel(csvData,headers) 
        {
            public Class getColumnClass(int columnIndex) {
                return java.lang.String.class;
            }

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return false;
            }
       };
       return tableModel;  
    }
    
    

    /**
     * Returns the MusicDB to be populated.
     * @return the MusicDB to be populated.
     */
    public MusicDB getDatabase() {
        return database;
    }

    /**
     * Sets the MusicDB to be populated.
     * @param database the MusicDB to be populated.
     */
    public void setDatabase(MusicDB database) {
        this.database = database;
    }

    public boolean getDoneImport() {
        return doneImport;
    }

    public void setDoneImport(boolean doneImport) {
        this.doneImport = doneImport;
    }
    
    
    
    
}
