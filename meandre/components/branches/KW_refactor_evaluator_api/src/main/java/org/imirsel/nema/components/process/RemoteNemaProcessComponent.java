package org.imirsel.nema.components.process;

import java.io.File;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.imirsel.nema.analytics.evaluation.SingleTrackEvalFileType;
import org.imirsel.nema.analytics.evaluation.classification.ClassificationTextFile;
import org.imirsel.nema.analytics.util.io.FileConversionUtil;
import org.imirsel.nema.analytics.util.io.NemaFileType;
import org.imirsel.nema.analytics.util.process.CommandLineFormatParser;
import org.imirsel.nema.components.RemoteProcessExecutorComponent;
import org.imirsel.nema.model.CommandLineTemplate;
import org.imirsel.nema.model.NemaData;
import org.imirsel.nema.model.NemaDataset;
import org.imirsel.nema.model.NemaMetadataEntry;
import org.imirsel.nema.model.NemaTask;
import org.imirsel.nema.model.NemaTrackList;
import org.imirsel.nema.model.ProcessArtifact;
import org.imirsel.nema.model.ProcessExecutionProperties;
import org.imirsel.nema.model.ProcessTemplate;
import org.imirsel.nema.monitor.process.NemaProcess;
import org.imirsel.nema.repository.RepositoryClientConnectionPool;
import org.imirsel.nema.repositoryservice.RepositoryClientInterface;
import org.meandre.annotations.Component;
import org.meandre.annotations.ComponentInput;
import org.meandre.annotations.ComponentOutput;
import org.meandre.core.ComponentContext;
import org.meandre.core.ComponentContextException;
import org.meandre.core.ComponentContextProperties;
import org.meandre.core.ComponentExecutionException;


@Component(creator = "kris.west@gmail.com", description = "Remote execution component that converts input NEMA models" +
		" into file formats (specified in the command formatting template of the chosen process), using file paths that" +
		" will be valid on the remote machine, transfers the input files to the remote machine and executes the process." +
		" The output of the process is harvested from the remote machine and read back into NEMA models and output." 
		, name = "RemoteNemaProcessComponent", tags = "remote execution",
		 firingPolicy = Component.FiringPolicy.all)
public class RemoteNemaProcessComponent extends RemoteProcessExecutorComponent {


	@ComponentInput(description = "NemaTask Object defining the task.", name = "NemaTask")
	public final static String DATA_INPUT_NEMATASK = "NemaTask";

//	@ComponentInput(description = "NemaDataset Object defining the task.", name = "NemaDataset")
//	public final static String DATA_INPUT_DATASET = "NemaDataset";

	@ComponentInput(description = "Map of NemaTrackList to List of NemaData Objects defining each track list (encoding any required metadata).", name = "DataToProcess")
	public final static String DATA_INPUT_DATA = "DataToProcess";

	@ComponentOutput(description = "Map of NemaTrackList to List of NemaData Objects defining each track list (encoding metadata generated by the remote process).",name = "PredictedData")
	private static final String DATA_OUTPUT="PredictedData";
	
	@Override
	public void initialize(ComponentContextProperties ccp)
	throws ComponentExecutionException, ComponentContextException {		
		super.initialize(ccp);
		
	}
	
	@Override
	public void dispose(ComponentContextProperties ccp)
	throws ComponentContextException {
		//super.dispose(ccp);
	}

	@SuppressWarnings("unchecked")
	@Override
	public void execute(ComponentContext cc)
			throws ComponentExecutionException, ComponentContextException {
		
		Map<NemaTrackList,List<File>> inputFiles = null;
		Map<NemaTrackList,List<File>> outputFiles = null;
		NemaTask task = null;
		//NemaDataset dataset = null;
		
		try {
			getLogger().info("Getting inputs...");
			//get inputs
			task = (NemaTask)cc.getDataComponentFromInput(DATA_INPUT_NEMATASK);
			//dataset = (NemaDataset)cc.getDataComponentFromInput(DATA_INPUT_DATASET);
			Map<NemaTrackList,List<NemaData>> dataToProcess = (Map<NemaTrackList,List<NemaData>>)cc.getDataComponentFromInput(DATA_INPUT_DATA);
			
			getLogger().info("Getting command formatting string...");
			//get command formatting string and parse
			ProcessTemplate pTemplate = this.getProcessTemplate();
			CommandLineTemplate cTemplate = pTemplate.getCommandLineTemplate();
			String commandlineFormat = cTemplate.getCommandLineFormatter();
			
			getLogger().info("Parsing command formatting string...");
			//parse and extract I/O classes and parameters
			CommandLineFormatParser formatModel = new CommandLineFormatParser(commandlineFormat);
			
			//Extract constraints from inputs
			//only dealing with input 1 as this is a 1 input component
			Class<? extends NemaFileType> inputType1 = formatModel.getInputType(1);
			Map<String,String> properties1 = formatModel.getInputProperties(1);
			
			HashSet<NemaMetadataEntry> encodingConstraint = new HashSet<NemaMetadataEntry>();
			String propsString = "";
			if(properties1 != null) {
				getLogger().info("Processing audio encoding properties...");
				
				for (Iterator<String> iterator = properties1.keySet().iterator(); iterator.hasNext();) {
					String key = iterator.next();
					String val = properties1.get(key);
					if (!val.trim().equals("")) {
						encodingConstraint.add(new NemaMetadataEntry(key, val));
					}
					propsString += key + "=" + val;
					if (iterator.hasNext()) {
						propsString += ",";
					}
				}
			}else {
				getLogger().info("No audio encoding properties to process...");
				
			}
			
			getLogger().info("Resolving tracks to audio paths...");
			
			//resolve tracks using repository
			RepositoryClientInterface client = RepositoryClientConnectionPool.getInstance().getFromPool();
			try {
				client.resolveTracksToFiles(dataToProcess,encodingConstraint);
			}catch(Exception e){
				throw new ComponentExecutionException("Exception occured while resolving tracks to files using properties: " + propsString,e);
			}finally {
				RepositoryClientConnectionPool.getInstance().returnToPool(client);
			}
			
			getLogger().info("Preparing process input files...");
			
			
			//perform conversion of input data into required formats
			inputFiles = FileConversionUtil.prepareProcessInput(new File(getAbsoluteProcessWorkingDirectory()), task, dataToProcess, inputType1);
			
			getLogger().info("Preparing process input file names...");
			
			//prepare output file names
			//only dealing with one output as this is a one output component
			Class<? extends NemaFileType> outputType1 = formatModel.getOutputType(1);
			Map<String,String> outputProperties1 = formatModel.getOutputProperties(1);
			NemaFileType outputTypeInstance = outputType1.newInstance();
			if(outputType1.equals(ClassificationTextFile.class)) {
				((ClassificationTextFile)outputTypeInstance).setMetadataType(task.getSubjectTrackMetadataName());
			}
			//TODO do something with output properties - could be file name extensions (e.g. if producing an opaque model file)
			outputFiles = FileConversionUtil.createOutputFileNames(dataToProcess, outputTypeInstance, ".out", new File(getAbsoluteResultLocationForJob()));

			
			//setup remote execution
			for (Iterator<NemaTrackList> setIt = inputFiles.keySet().iterator(); setIt
					.hasNext();) {
				NemaTrackList testSet = setIt.next();
				
				getLogger().info("Performing executions for test set " + testSet.getFoldNumber() + ", id: " + testSet.getId());
 				List<File> inputs1ForFold = inputFiles.get(testSet);
				List<File> outputs1ForFold = outputFiles.get(testSet);
				
				//check inputs and outputTypes are matched if we are doing a 1 in 1 out process
				if (SingleTrackEvalFileType.class.isAssignableFrom(inputType1.getClass()) &&
						SingleTrackEvalFileType.class.isAssignableFrom(outputType1.getClass())) {
					if(inputs1ForFold.size() != outputs1ForFold.size()) {
						throw new ComponentExecutionException("List of input files (" + inputs1ForFold.size() + ") and output files (" + outputs1ForFold.size() + ") are different lengths, when they should be matched!");
					}
				}
				
				//execute for this fold, once per input file
				File inputFile,outputFile;
				for (int i=0;i<inputs1ForFold.size();i++) {
					inputFile = inputs1ForFold.get(i);
					if (outputs1ForFold.size() == 1) {
						//output is always the same file
						outputFile = outputs1ForFold.get(0);
					}else {
						outputFile = outputs1ForFold.get(i);
					}
					formatModel.clearPreparedPaths();
					formatModel.setPreparedPathForInput(1, inputFile.getAbsolutePath());
					formatModel.setPreparedPathForOutput(1, outputFile.getAbsolutePath());
					
					ProcessArtifact paInputs = new ProcessArtifact(inputFile.getAbsolutePath(),"File");
					List<ProcessArtifact> inputs = new ArrayList<ProcessArtifact>();
					inputs.add(paInputs);
					
					ProcessArtifact paOutputs = new ProcessArtifact(outputFile.getAbsolutePath(),"File");
					List<ProcessArtifact> outputs = new ArrayList<ProcessArtifact>();
					outputs.add(paOutputs);
					
					ProcessExecutionProperties pep = new ProcessExecutionProperties();
					pep.setId(cc.getExecutionInstanceID());
					pep.setOutputs(outputs);
					pep.setInputs(inputs);
					
					//set the formatted command arguments to run from formatModel
					//TODO check this is the right place to setting this...
					pep.setCommandLineFlags(formatModel.toFormattedString());

					getLogger().info("Executing process...");
					@SuppressWarnings("unused")
					final NemaProcess np=this.executeProcess(pep);
					getLogger().info("Executed process. Waiting for the process to end...");
					this.waitForProcess();
					
					//We do not need to do this as we already know the paths to outputTypes on shared storage
					//List<ProcessArtifact> list = this.getResult();
				}	
			}
		
			getLogger().info("Process ended. Processing results...");
			
			//read and interpret results from all folds
			Map<NemaTrackList,List<NemaData>> outputData = FileConversionUtil.readProcessOutput(outputFiles, task, outputType1);
			
			if(outputData==null){
				throw new ComponentExecutionException("Process result is null");
			}else{
				cc.pushDataComponentToOutput(DATA_OUTPUT, outputData);
			}
			
		} catch(Exception e) {
			throw new ComponentExecutionException("Exception occurred while attempting to execute a remote process",e);
		}	
		
	}


}
