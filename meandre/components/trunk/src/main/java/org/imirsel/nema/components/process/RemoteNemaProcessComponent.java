package org.imirsel.nema.components.process;

import java.io.File;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import org.imirsel.nema.analytics.util.process.CommandArgument;
import org.imirsel.nema.analytics.util.process.CommandLineFormatParser;
import org.imirsel.nema.components.InvalidProcessMonitorException;
import org.imirsel.nema.components.InvalidProcessTemplateException;
import org.imirsel.nema.components.RemoteProcessExecutorComponent;
import org.imirsel.nema.model.CommandLineTemplate;
import org.imirsel.nema.model.NemaData;
import org.imirsel.nema.model.NemaMetadataEntry;
import org.imirsel.nema.model.NemaTask;
import org.imirsel.nema.model.NemaTrackList;
import org.imirsel.nema.model.ProcessArtifact;
import org.imirsel.nema.model.ProcessExecutionProperties;
import org.imirsel.nema.model.ProcessTemplate;
import org.imirsel.nema.model.fileTypes.ClassificationTextFile;
import org.imirsel.nema.model.fileTypes.NemaFileType;
import org.imirsel.nema.model.fileTypes.SingleTrackEvalFileType;
import org.imirsel.nema.model.util.FileConversionUtil;
import org.imirsel.nema.monitor.process.NemaProcess;
import org.imirsel.nema.repository.RepositoryClientConnectionPool;
import org.imirsel.nema.repositoryservice.RepositoryClientInterface;
import org.meandre.annotations.Component;
import org.meandre.annotations.ComponentInput;
import org.meandre.annotations.ComponentOutput;
import org.meandre.core.ComponentContext;
import org.meandre.core.ComponentContextException;
import org.meandre.core.ComponentContextProperties;
import org.meandre.core.ComponentExecutionException;

/**
 * @deprecated
 * @author kris.west@gmail.com
 * @since 0.1.0
 */
@Deprecated
@Component(creator = "kris.west@gmail.com", description = "Remote execution component that converts input NEMA models" +
		" into file formats (specified in the command formatting template of the chosen process), using file paths that" +
		" will be valid on the remote machine, transfers the input files to the remote machine and executes the process." +
		" The output of the process is harvested from the remote machine and read back into NEMA models and output." 
		, name = "RemoteNemaProcessComponent", tags = "remote execution",
		 firingPolicy = Component.FiringPolicy.all)
public class RemoteNemaProcessComponent extends RemoteProcessExecutorComponent {


	@ComponentInput(description = "NemaTask Object defining the task.", name = "NemaTask")
	public final static String DATA_INPUT_NEMATASK = "NemaTask";

	@ComponentInput(description = "Map of NemaTrackList to List of NemaData Objects defining each track list (encoding any required metadata).", name = "DataToProcess")
	public final static String DATA_INPUT_DATA = "DataToProcess";

	@ComponentOutput(description = "Map of NemaTrackList to List of NemaData Objects defining each track list (encoding metadata generated by the remote process).",name = "PredictedData")
	private static final String DATA_OUTPUT="PredictedData";
	
	@Override
	public void initialize(ComponentContextProperties ccp)
	throws ComponentExecutionException, ComponentContextException {		
		super.initialize(ccp);
		
	}
	
	@Override
	public void dispose(ComponentContextProperties ccp)
	throws ComponentContextException {
		//super.dispose(ccp);
	}

	@SuppressWarnings("unchecked")
	@Override
	public void execute(ComponentContext cc)
			throws ComponentExecutionException, ComponentContextException {
		
		Map<NemaTrackList,List<File>> inputFiles = null;
		Map<NemaTrackList,List<File>> outputFiles = null;
		NemaTask task = null;
		//NemaDataset dataset = null;
		
			getLogger().info("Getting inputs...");
			//get inputs
			task = (NemaTask)cc.getDataComponentFromInput(DATA_INPUT_NEMATASK);
			//dataset = (NemaDataset)cc.getDataComponentFromInput(DATA_INPUT_DATASET);
			Map<NemaTrackList,List<NemaData>> dataToProcess = (Map<NemaTrackList,List<NemaData>>)cc.getDataComponentFromInput(DATA_INPUT_DATA);

			getLogger().info("Getting command formatting string...");
			//get command formatting string and parse
			ProcessTemplate pTemplate = null;
			try {
				pTemplate = this.getProcessTemplate();
			} catch (RemoteException e1) {
				throw new ComponentExecutionException(e1);
			} catch (InvalidProcessTemplateException e1) {
				throw new ComponentExecutionException(e1);
			}
			CommandLineTemplate cTemplate = pTemplate.getCommandLineTemplate();
			String commandlineFormat = cTemplate.getCommandLineFormatter();
			getLogger().info("Parsing command formatting string: " + commandlineFormat);
			if (commandlineFormat.contains("\n")){
				commandlineFormat = commandlineFormat.replaceAll("\n", " ");
				getLogger().warning("Comamnd format string contained new line characters. These were replaced with spaces");
			}
			//parse and extract I/O classes and parameters
			CommandLineFormatParser formatModel = new CommandLineFormatParser(commandlineFormat);
			getLogger().info("Format string parsed as: " + formatModel.toConfigString());
			
			String args = "Number of command argument parts: " + formatModel.getArguments().size() + "\n"; 
			int count = 0;
			for (Iterator<CommandArgument> iterator = formatModel.getArguments().iterator(); iterator.hasNext();) {
				CommandArgument arg = iterator.next();
				args += "\t" + count++ + ": " + arg.toConfigString() + "\n";  
			}
			getLogger().info(args);
			
			//Extract constraints from inputs
			//only dealing with input 1 as this is a 1 input component
			Class<? extends NemaFileType> inputType1 = formatModel.getInputType(1);
			Map<String,String> properties1 = formatModel.getInputProperties(1);
			
			HashSet<NemaMetadataEntry> encodingConstraint = new HashSet<NemaMetadataEntry>();
			String propsString = "";
			if(properties1 != null) {
				getLogger().info("Processing audio encoding properties...");
				
				for (Iterator<String> iterator = properties1.keySet().iterator(); iterator.hasNext();) {
					String key = iterator.next();
					String val = properties1.get(key);
					if (!val.trim().equals("")) {
						encodingConstraint.add(new NemaMetadataEntry(key, val));
					}
					propsString += key + "=" + val;
					if (iterator.hasNext()) {
						propsString += ",";
					}
				}
			}else {
				getLogger().info("No audio encoding properties to process...");
				
			}
			
			getLogger().info("Resolving tracks to audio paths...");
			RepositoryClientInterface client =null;
			try {
				//resolve tracks using repository
				client = RepositoryClientConnectionPool.getInstance().getFromPool();
				client.resolveTracksToFiles(dataToProcess,encodingConstraint);
			}catch(Exception e){
				throw new ComponentExecutionException("Exception occured while resolving tracks to files using properties: " + propsString,e);
			}finally {
				RepositoryClientConnectionPool.getInstance().returnToPool(client);
			}
			
			getLogger().info("Preparing process input files...");
			
			
			//perform conversion of input data into required formats
			try {
				inputFiles = FileConversionUtil.prepareProcessInput(new File(getAbsoluteProcessWorkingDirectory()), task, dataToProcess, inputType1);
			} catch (Exception e) {
				throw new ComponentExecutionException(e);
			}
			
			getLogger().info("Preparing process output file names...");
			
			//prepare output file names
			//only dealing with one output as this is a one output component
			Class<? extends NemaFileType> outputType1 = formatModel.getOutputType(1);
			Map<String,String> outputProperties1 = formatModel.getOutputProperties(1);
			NemaFileType outputTypeInstance=null;
			try {
				outputTypeInstance = outputType1.newInstance();
			} catch (InstantiationException e) {
				throw new ComponentExecutionException(e);
			} catch (IllegalAccessException e) {
				throw new ComponentExecutionException(e);
			}
			if(outputType1.equals(ClassificationTextFile.class)) {
				((ClassificationTextFile)outputTypeInstance).setMetadataType(task.getSubjectTrackMetadataName());
			}
			//TODO do something with output properties - could be file name extensions (e.g. if producing an opaque model file)
			outputFiles = FileConversionUtil.createOutputFileNames(dataToProcess, inputType1, outputTypeInstance, new File(getAbsoluteResultLocationForJob()));

			
			//setup remote execution
			for (Iterator<NemaTrackList> setIt = inputFiles.keySet().iterator(); setIt
					.hasNext();) {
				NemaTrackList testSet = setIt.next();
				
				getLogger().info("Performing executions for test set " + testSet.getFoldNumber() + ", id: " + testSet.getId());
 				List<File> inputs1ForFold = inputFiles.get(testSet);
				List<File> outputs1ForFold = outputFiles.get(testSet);
				
				//check inputs and outputTypes are matched if we are doing a 1 in 1 out process
				if (SingleTrackEvalFileType.class.isAssignableFrom(inputType1.getClass()) &&
						SingleTrackEvalFileType.class.isAssignableFrom(outputType1.getClass())) {
					if(inputs1ForFold.size() != outputs1ForFold.size()) {
						throw new ComponentExecutionException("List of input files (" + inputs1ForFold.size() + ") and output files (" + outputs1ForFold.size() + ") are different lengths, when they should be matched!");
					}
				}
				
				//execute for this fold, once per input file
				File inputFile,outputFile;
				for (int i=0;i<inputs1ForFold.size();i++) {
					inputFile = inputs1ForFold.get(i);
					if (outputs1ForFold.size() == 1) {
						//output is always the same file
						outputFile = outputs1ForFold.get(0);
					}else {
						outputFile = outputs1ForFold.get(i);
					}
					this.getLogger().info("Running for the output file: " + outputFile);
					formatModel.clearPreparedPaths();
					formatModel.setPreparedPathForInput(1, inputFile.getAbsolutePath());
					formatModel.setPreparedPathForOutput(1, outputFile.getAbsolutePath());
					
					//TODO: set unique scratch for each execution rather than fold scratch
					//mint scratch dir
					String scratch = this.getAbsoluteProcessWorkingDirectory() + File.separator + "testSet" + testSet.getId() + "_" + inputFile.getName();
					if(!new File(scratch).mkdirs()){
						throw new ComponentExecutionException("Failed to create scratch dir for a process execution at: " + scratch);
 					}
					formatModel.setPreparedPathForScratchDir(scratch);
					
					
					//TODO: handle site dependencies?
					
					ProcessArtifact paInputs = new ProcessArtifact(inputFile.getAbsolutePath(),"File");
					List<ProcessArtifact> inputs = new ArrayList<ProcessArtifact>();
					inputs.add(paInputs);
					
					ProcessArtifact paOutputs = new ProcessArtifact(outputFile.getAbsolutePath(),"File");
					List<ProcessArtifact> outputs = new ArrayList<ProcessArtifact>();
					outputs.add(paOutputs);
					
					ProcessExecutionProperties pep = new ProcessExecutionProperties();
					pep.setId(cc.getFlowExecutionInstanceID());
					pep.setOutputs(outputs);
					pep.setInputs(inputs);
					
					//set the formatted command arguments to run from formatModel
					String formattedArgs = formatModel.toFormattedString();
					pep.setCommandLineFlags(formattedArgs);
				
					getLogger().info("Executing process... " + i + "\n");
					NemaProcess nemaProcess=null;
					try {
						nemaProcess=this.executeProcess(pep);
					} catch (RemoteException e) {
						throw new ComponentExecutionException(e);
					} catch (InvalidProcessMonitorException e) {
						throw new ComponentExecutionException(e);
					} catch (InvalidProcessTemplateException e) {
						throw new ComponentExecutionException(e);
					}
					getLogger().info("Executed process. Waiting for the process to end..." + i + "\n");
					try {
						this.waitForProcess(nemaProcess);
					} catch (InterruptedException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
					getLogger().info("Done Waiting..." +i +"\n");
					//We do not need to do this as we already know the paths to outputTypes on shared storage
					List<ProcessArtifact> list = this.getResult(nemaProcess);
					// cleanup the process
					this.cleanProcess(nemaProcess);
					
				}	
			}
		
			getLogger().info("All Processes ended. Processing results...\n");
			
			//read and interpret results from all folds
			Map<NemaTrackList, List<NemaData>> outputData = null;
			try {
				outputData = FileConversionUtil.readProcessOutput(outputFiles, task, outputType1);
			}catch(Exception e) {
			 throw new ComponentExecutionException(e);
			}
			
			if(outputData==null){
				throw new ComponentExecutionException("Process result is null");
			}else{
				cc.pushDataComponentToOutput(DATA_OUTPUT, outputData);
			}
			
	
		
	}


}
