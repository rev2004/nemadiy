/*
 * HistogramPanel.java
 *
 * Created on February 3, 2008, 8:14 PM
 */
package org.imirsel.m2k.vis;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Image;
import java.awt.Rectangle;
import java.io.Serializable;
import java.util.ArrayList;

/**
 *
 * @author  kriswest
 */
public class HistogramPanel extends javax.swing.JPanel implements Serializable {

    private Dimension offDimension;
    private Image offImage;
    private Graphics offGraphics;
    private String[] classLabels;
    private int TopMarginSize = 31;
    private int BottomMarginSize = 60;
    private int LeftMarginSize = 31;
    private int RightMarginSize = 5;
    double UserSpecifiedMin = 0;
    double UserSpecifiedMax = 1.0;
    boolean normalize = true;
    private double[] likelihoods;
    private boolean newData;
    private static final Color[] Colors = {new Color(0.25f, 0.5f, 0.75f), new Color(1.0f, 0.0f, 0.0f), new Color(0.0f, 1.0f, 0.0f),
        new Color(0.0f, 0.0f, 1.0f), new Color(1.0f, 1.0f, 0.0f), new Color(1.0f, 0.0f, 1.0f), new Color(0.0f, 0.5f, 0.5f),
        new Color(0.5f, 0.0f, 0.0f), new Color(0.0f, 0.5f, 0.0f), new Color(0.0f, 0.0f, 0.5f), new Color(0.5f, 0.5f, 0.0f),
        new Color(0.5f, 0.5f, 1.0f), new Color(0.5f, 1.0f, 0.5f),
        new Color(1.0f, 0.5f, 0.5f)
    };

    public HistogramPanel() {
        normalize = true;
        UserSpecifiedMin = 0.0;
        UserSpecifiedMax = 1.0;

        newData = false;
        likelihoods = null;
        classLabels = null;

        initComponents();
    }

    /**
     * Creates new form HistogramPanel 
     * @param normalize_
     * @param UserSpecifiedMin_
     * @param UserSpecifiedMax_
     */
    public HistogramPanel(boolean normalize_, double UserSpecifiedMin_, double UserSpecifiedMax_) {
        normalize = normalize_;
        UserSpecifiedMin = UserSpecifiedMin_;
        UserSpecifiedMax = UserSpecifiedMax_;

        newData = false;
        likelihoods = null;
        classLabels = null;

        initComponents();
    }

    public void setClassLabels(String[] classLabels_) {
        classLabels = classLabels_;
    }

    public void addNewData(double[] data) {
        synchronized (this) {
            likelihoods = data;
            newData = true;
        }
        this.repaint();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 651, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 467, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    /**
     * Splits words into multiple lines  for x-axis labeling to avoid problems with x-axis labels interfering
     * with one another
     * @param mess the words to split
     * @return the split words
     */
    public ArrayList<String> splitWords(String mess) {
        ArrayList<String> words = new ArrayList<String>();

        int mess_len = mess.length();
        int word_start = 0;

        for (int i = 1; i < mess_len; i++) {
            char c = mess.charAt(i);
            if (Character.getType(c) == ',') {
                int word_end = i;
                String word = mess.substring(word_start, word_end);
                words.add(word);
                word_start = i;
            }
        }

        String word = mess.substring(word_start, mess_len);
        words.add(word);

        return words;
    }

    public void paint(Graphics g) {
        System.out.println("Painting histogram");
        Dimension d = getSize();
        if ((offGraphics == null) || (d.width != offDimension.width) || (d.height != offDimension.height)) {
            offDimension = d;
            offImage = createImage(d.width, d.height);
            offGraphics = offImage.getGraphics();
        }
        offGraphics.setColor(new Color(1.0f, 1.0f, 1.0f));
        offGraphics.clearRect(1, 1, d.width, d.height);
        
        Rectangle bounds = getBounds();
        int Xsize = (int) (bounds.getWidth() - LeftMarginSize) - RightMarginSize;
        int Ysize = (int) (bounds.getHeight() - TopMarginSize) - BottomMarginSize;


        //offGraphics.setColor(new Color(1.0f, 1.0f, 1.0f));
        offGraphics.clearRect(LeftMarginSize, TopMarginSize, LeftMarginSize + Xsize, BottomMarginSize + Ysize);
        
        if (likelihoods != null) {
            int NumSamples = likelihoods.length;

            double min = Double.NaN;
            double max = Double.NaN;

            if (normalize) {
                min = Double.POSITIVE_INFINITY;
                max = Double.NEGATIVE_INFINITY;

                for (int i = 0; i < NumSamples; i++) {
                    if (likelihoods[i] > max) {
                        max = likelihoods[i];
                    }
                    if (likelihoods[i] < min) {
                        min = likelihoods[i];
                    }
                }
            } else {
                min = UserSpecifiedMin;
                max = UserSpecifiedMax;
            }
            double range = max - min;

            double[] scaledData = new double[NumSamples];

            for (int i = 0; i < NumSamples; i++) {
                if (range == 0) {
                    scaledData[i] = 0.5;
                } else {
                    scaledData[i] = (likelihoods[i] - min) / (range);
                }
            }


            double Xfactor = (double) Xsize / (double) (NumSamples);
            
            offGraphics.setColor(new Color(0.0f, 0.0f, 0.0f));
            offGraphics.drawLine(LeftMarginSize, Ysize + TopMarginSize, LeftMarginSize + Xsize, Ysize + TopMarginSize);

            double X1 = -1;
            double Y1 = -1;
            for (int i = 0; i < NumSamples; i++) {

                X1 = (i) * Xfactor;

                Y1 = scaledData[i] * Ysize;

                int barOrgX = LeftMarginSize + (int) X1;
                int barOrgY = TopMarginSize + (int) (Ysize - Y1);
                int barDimX = (int) ((Xfactor - 2.0) + 0.5);
                int barDimY = (int) Y1;

                offGraphics.setColor(new Color(0.0f, 0.0f, 0.0f));
                offGraphics.fillRect(barOrgX, barOrgY, barDimX, barDimY);

                offGraphics.setColor(Colors[i % 20]);
                offGraphics.fillRect(barOrgX + 2, barOrgY + 2, barDimX - 4, barDimY - 4);

                offGraphics.setColor(new Color(0.0f, 0.0f, 0.0f));

                if (classLabels != null) {
                    Font font = new Font("SansSerif", Font.PLAIN, 9);
                    offGraphics.setFont(font);
                    
                    FontMetrics metrics = offGraphics.getFontMetrics(font);

                    String fullMess = classLabels[i];
                    ArrayList<String> words = new ArrayList<String>();
                    //splitWords(fullMess);
                    int lastChar = 0;
                    for (int j = 1; j < fullMess.length(); j++) {
                        String testString = fullMess.substring(lastChar,j);
                        int messWidth = metrics.stringWidth(testString);
                        if (messWidth >= (barDimX - 5)){
                            words.add(testString);
                            lastChar = j;
                        }
                    }
                    String testString = fullMess.substring(lastChar,fullMess.length());
                    if (!testString.trim().equals("")){
                        words.add(testString);
                    }

                    int num_words = words.size();

                    int labelYOrg = (TopMarginSize + Ysize + TopMarginSize / 2);

                    for (int w = 0; w < num_words; w++) {
                        String mess = words.get(w);

                        int messWidth = metrics.stringWidth(mess);
                        int messHeight = metrics.getHeight();

                        int labelXOrg = (int) (LeftMarginSize + X1 + (Xfactor - messWidth) / 2);
                        offGraphics.drawString(mess, labelXOrg, labelYOrg);

                        labelYOrg += messHeight;
                    }
                }

            }
        }
        g.drawImage(offImage, 0, 0, null);
    }

    /**
     * Overrides the update method for the double buffering.
     * @param g A Graphics instance that is shown to the user.
     */
    public void update(Graphics g) {
        //super.update(g);

        if (newData) {
            paint(g);
            newData = false;
        } else if (offImage == null) {
            paint(g);
        } else {
            g.drawImage(offImage, 0, 0, null);
        }
    }
}



